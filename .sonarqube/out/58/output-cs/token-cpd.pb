ку
БC:\Users\jay.ahir\Desktop\OrchardCore-main\OrchardCore-main\src\OrchardCore\OrchardCore.FileStorage.FileSystem\FileSystemStore.cs
	namespace 	
OrchardCore
 
. 
FileStorage !
.! "

FileSystem" ,
{		 
public

 

class

 
FileSystemStore

  
:

! "

IFileStore

# -
{ 
private 
readonly 
string 
_fileSystemPath  /
;/ 0
public 
FileSystemStore 
( 
string %
fileSystemPath& 4
)4 5
{ 	
_fileSystemPath 
= 
Path "
." #
GetFullPath# .
(. /
fileSystemPath/ =
)= >
;> ?
} 	
public 
Task 
< 
IFileStoreEntry #
># $
GetFileInfoAsync% 5
(5 6
string6 <
path= A
)A B
{ 	
try 
{ 
var 
physicalPath  
=! "
GetPhysicalPath# 2
(2 3
path3 7
)7 8
;8 9
var 
fileInfo 
= 
new "
PhysicalFileInfo# 3
(3 4
new4 7
FileInfo8 @
(@ A
physicalPathA M
)M N
)N O
;O P
if 
( 
fileInfo 
. 
Exists #
)# $
{ 
return 
Task 
.  

FromResult  *
<* +
IFileStoreEntry+ :
>: ;
(; <
new< ? 
FileSystemStoreEntry@ T
(T U
pathU Y
,Y Z
fileInfo[ c
)c d
)d e
;e f
} 
return   
Task   
.   

FromResult   &
<  & '
IFileStoreEntry  ' 6
>  6 7
(  7 8
null  8 <
)  < =
;  = >
}!! 
catch"" 
("" 
	Exception"" 
ex"" 
)""  
{## 
throw$$ 
new$$ 
FileStoreException$$ ,
($$, -
$"$$- /
$str$$/ O
{$$O P
path$$P T
}$$T U
$str$$U W
"$$W X
,$$X Y
ex$$Z \
)$$\ ]
;$$] ^
}%% 
}&& 	
public(( 
Task(( 
<(( 
IFileStoreEntry(( #
>((# $!
GetDirectoryInfoAsync((% :
(((: ;
string((; A
path((B F
)((F G
{)) 	
try** 
{++ 
var,, 
physicalPath,,  
=,,! "
GetPhysicalPath,,# 2
(,,2 3
path,,3 7
),,7 8
;,,8 9
var.. 
directoryInfo.. !
=.." #
new..$ '!
PhysicalDirectoryInfo..( =
(..= >
new..> A
DirectoryInfo..B O
(..O P
physicalPath..P \
)..\ ]
)..] ^
;..^ _
if00 
(00 
directoryInfo00 !
.00! "
Exists00" (
)00( )
{11 
return22 
Task22 
.22  

FromResult22  *
<22* +
IFileStoreEntry22+ :
>22: ;
(22; <
new22< ? 
FileSystemStoreEntry22@ T
(22T U
path22U Y
,22Y Z
directoryInfo22[ h
)22h i
)22i j
;22j k
}33 
return55 
Task55 
.55 

FromResult55 &
<55& '
IFileStoreEntry55' 6
>556 7
(557 8
null558 <
)55< =
;55= >
}66 
catch77 
(77 
	Exception77 
ex77 
)77  
{88 
throw99 
new99 
FileStoreException99 ,
(99, -
$"99- /
$str99/ T
{99T U
path99U Y
}99Y Z
$str99Z \
"99\ ]
,99] ^
ex99_ a
)99a b
;99b c
}:: 
};; 	
public== 
IAsyncEnumerable== 
<==  
IFileStoreEntry==  /
>==/ 0$
GetDirectoryContentAsync==1 I
(==I J
string==J P
path==Q U
===V W
null==X \
,==\ ]
bool==^ b!
includeSubDirectories==c x
===y z
false	=={ А
)
==А Б
{>> 	
try?? 
{@@ 
varAA 
physicalPathAA  
=AA! "
GetPhysicalPathAA# 2
(AA2 3
pathAA3 7
)AA7 8
;AA8 9
varBB 
resultsBB 
=BB 
newBB !
ListBB" &
<BB& '
IFileStoreEntryBB' 6
>BB6 7
(BB7 8
)BB8 9
;BB9 :
ifDD 
(DD 
!DD 
	DirectoryDD 
.DD 
ExistsDD %
(DD% &
physicalPathDD& 2
)DD2 3
)DD3 4
{EE 
returnFF 
resultsFF "
.FF" #
ToAsyncEnumerableFF# 4
(FF4 5
)FF5 6
;FF6 7
}GG 
resultsJJ 
.JJ 
AddRangeJJ  
(JJ  !
	DirectoryKK 
.LL 
GetDirectoriesLL '
(LL' (
physicalPathLL( 4
,LL4 5
$strLL6 9
,LL9 :!
includeSubDirectoriesLL; P
?LLQ R
SearchOptionLLS _
.LL_ `
AllDirectoriesLL` n
:LLo p
SearchOptionLLq }
.LL} ~
TopDirectoryOnly	LL~ О
)
LLО П
.MM 
SelectMM 
(MM  
fMM  !
=>MM" $
{NN 
varOO 
fileSystemInfoOO  .
=OO/ 0
newOO1 4!
PhysicalDirectoryInfoOO5 J
(OOJ K
newOOK N
DirectoryInfoOOO \
(OO\ ]
fOO] ^
)OO^ _
)OO_ `
;OO` a
varPP 
fileRelativePathPP  0
=PP1 2
fPP3 4
.PP4 5
	SubstringPP5 >
(PP> ?
_fileSystemPathPP? N
.PPN O
LengthPPO U
)PPU V
;PPV W
varQQ 
filePathQQ  (
=QQ) *
thisQQ+ /
.QQ/ 0
NormalizePathQQ0 =
(QQ= >
fileRelativePathQQ> N
)QQN O
;QQO P
returnRR "
newRR# & 
FileSystemStoreEntryRR' ;
(RR; <
filePathRR< D
,RRD E
fileSystemInfoRRF T
)RRT U
;RRU V
}SS 
)SS 
)SS 
;SS 
resultsVV 
.VV 
AddRangeVV  
(VV  !
	DirectoryWW 
.XX 
GetFilesXX !
(XX! "
physicalPathXX" .
,XX. /
$strXX0 3
,XX3 4!
includeSubDirectoriesXX5 J
?XXK L
SearchOptionXXM Y
.XXY Z
AllDirectoriesXXZ h
:XXi j
SearchOptionXXk w
.XXw x
TopDirectoryOnly	XXx И
)
XXИ Й
.YY 
SelectYY 
(YY  
fYY  !
=>YY" $
{ZZ 
var[[ 
fileSystemInfo[[  .
=[[/ 0
new[[1 4
PhysicalFileInfo[[5 E
([[E F
new[[F I
FileInfo[[J R
([[R S
f[[S T
)[[T U
)[[U V
;[[V W
var\\ 
fileRelativePath\\  0
=\\1 2
f\\3 4
.\\4 5
	Substring\\5 >
(\\> ?
_fileSystemPath\\? N
.\\N O
Length\\O U
)\\U V
;\\V W
var]] 
filePath]]  (
=]]) *
this]]+ /
.]]/ 0
NormalizePath]]0 =
(]]= >
fileRelativePath]]> N
)]]N O
;]]O P
return^^ "
new^^# & 
FileSystemStoreEntry^^' ;
(^^; <
filePath^^< D
,^^D E
fileSystemInfo^^F T
)^^T U
;^^U V
}__ 
)__ 
)__ 
;__ 
returnaa 
resultsaa 
.aa 
ToAsyncEnumerableaa 0
(aa0 1
)aa1 2
;aa2 3
}bb 
catchcc 
(cc 
	Exceptioncc 
excc 
)cc  
{dd 
throwee 
newee 
FileStoreExceptionee ,
(ee, -
$"ee- /
$stree/ W
{eeW X
patheeX \
}ee\ ]
$stree] _
"ee_ `
,ee` a
exeeb d
)eed e
;eee f
}ff 
}gg 	
publicii 
Taskii 
<ii 
boolii 
>ii #
TryCreateDirectoryAsyncii 1
(ii1 2
stringii2 8
pathii9 =
)ii= >
{jj 	
trykk 
{ll 
varmm 
physicalPathmm  
=mm! "
GetPhysicalPathmm# 2
(mm2 3
pathmm3 7
)mm7 8
;mm8 9
ifoo 
(oo 
Fileoo 
.oo 
Existsoo 
(oo  
physicalPathoo  ,
)oo, -
)oo- .
{pp 
throwqq 
newqq 
FileStoreExceptionqq 0
(qq0 1
$"qq1 3
$strqq3 ]
{qq] ^
pathqq^ b
}qqb c
$str	qqc В
"
qqВ Г
)
qqГ Д
;
qqД Е
}rr 
iftt 
(tt 
	Directorytt 
.tt 
Existstt $
(tt$ %
physicalPathtt% 1
)tt1 2
)tt2 3
{uu 
returnvv 
Taskvv 
.vv  

FromResultvv  *
(vv* +
falsevv+ 0
)vv0 1
;vv1 2
}ww 
	Directoryyy 
.yy 
CreateDirectoryyy )
(yy) *
physicalPathyy* 6
)yy6 7
;yy7 8
return{{ 
Task{{ 
.{{ 

FromResult{{ &
({{& '
true{{' +
){{+ ,
;{{, -
}|| 
catch}} 
(}} 
FileStoreException}} %
)}}% &
{~~ 
throw 
; 
}
АА 
catch
ББ 
(
ББ 
	Exception
ББ 
ex
ББ 
)
ББ  
{
ВВ 
throw
ГГ 
new
ГГ  
FileStoreException
ГГ ,
(
ГГ, -
$"
ГГ- /
$str
ГГ/ H
{
ГГH I
path
ГГI M
}
ГГM N
$str
ГГN P
"
ГГP Q
,
ГГQ R
ex
ГГS U
)
ГГU V
;
ГГV W
}
ДД 
}
ЕЕ 	
public
ЗЗ 
Task
ЗЗ 
<
ЗЗ 
bool
ЗЗ 
>
ЗЗ  
TryDeleteFileAsync
ЗЗ ,
(
ЗЗ, -
string
ЗЗ- 3
path
ЗЗ4 8
)
ЗЗ8 9
{
ИИ 	
try
ЙЙ 
{
КК 
var
ЛЛ 
physicalPath
ЛЛ  
=
ЛЛ! "
GetPhysicalPath
ЛЛ# 2
(
ЛЛ2 3
path
ЛЛ3 7
)
ЛЛ7 8
;
ЛЛ8 9
if
НН 
(
НН 
!
НН 
File
НН 
.
НН 
Exists
НН  
(
НН  !
physicalPath
НН! -
)
НН- .
)
НН. /
{
ОО 
return
ПП 
Task
ПП 
.
ПП  

FromResult
ПП  *
(
ПП* +
false
ПП+ 0
)
ПП0 1
;
ПП1 2
}
РР 
File
ТТ 
.
ТТ 
Delete
ТТ 
(
ТТ 
physicalPath
ТТ (
)
ТТ( )
;
ТТ) *
return
ФФ 
Task
ФФ 
.
ФФ 

FromResult
ФФ &
(
ФФ& '
true
ФФ' +
)
ФФ+ ,
;
ФФ, -
}
ХХ 
catch
ЦЦ 
(
ЦЦ 
	Exception
ЦЦ 
ex
ЦЦ 
)
ЦЦ  
{
ЧЧ 
throw
ШШ 
new
ШШ  
FileStoreException
ШШ ,
(
ШШ, -
$"
ШШ- /
$str
ШШ/ C
{
ШШC D
path
ШШD H
}
ШШH I
$str
ШШI K
"
ШШK L
,
ШШL M
ex
ШШN P
)
ШШP Q
;
ШШQ R
}
ЩЩ 
}
ЪЪ 	
public
ЬЬ 
Task
ЬЬ 
<
ЬЬ 
bool
ЬЬ 
>
ЬЬ %
TryDeleteDirectoryAsync
ЬЬ 1
(
ЬЬ1 2
string
ЬЬ2 8
path
ЬЬ9 =
)
ЬЬ= >
{
ЭЭ 	
try
ЮЮ 
{
ЯЯ 
var
аа 
physicalPath
аа  
=
аа! "
GetPhysicalPath
аа# 2
(
аа2 3
path
аа3 7
)
аа7 8
;
аа8 9
if
вв 
(
вв 
!
вв 
	Directory
вв 
.
вв 
Exists
вв %
(
вв% &
physicalPath
вв& 2
)
вв2 3
)
вв3 4
{
гг 
return
дд 
Task
дд 
.
дд  

FromResult
дд  *
(
дд* +
false
дд+ 0
)
дд0 1
;
дд1 2
}
ее 
	Directory
зз 
.
зз 
Delete
зз  
(
зз  !
physicalPath
зз! -
,
зз- .
	recursive
зз/ 8
:
зз8 9
true
зз: >
)
зз> ?
;
зз? @
return
йй 
Task
йй 
.
йй 

FromResult
йй &
(
йй& '
true
йй' +
)
йй+ ,
;
йй, -
}
кк 
catch
лл 
(
лл 
	Exception
лл 
ex
лл 
)
лл  
{
мм 
throw
нн 
new
нн  
FileStoreException
нн ,
(
нн, -
$"
нн- /
$str
нн/ H
{
ннH I
path
ннI M
}
ннM N
$str
ннN P
"
ннP Q
,
ннQ R
ex
ннS U
)
ннU V
;
ннV W
}
оо 
}
пп 	
public
▒▒ 
Task
▒▒ 
MoveFileAsync
▒▒ !
(
▒▒! "
string
▒▒" (
oldPath
▒▒) 0
,
▒▒0 1
string
▒▒2 8
newPath
▒▒9 @
)
▒▒@ A
{
▓▓ 	
try
││ 
{
┤┤ 
var
╡╡ 
physicalOldPath
╡╡ #
=
╡╡$ %
GetPhysicalPath
╡╡& 5
(
╡╡5 6
oldPath
╡╡6 =
)
╡╡= >
;
╡╡> ?
if
╖╖ 
(
╖╖ 
!
╖╖ 
File
╖╖ 
.
╖╖ 
Exists
╖╖  
(
╖╖  !
physicalOldPath
╖╖! 0
)
╖╖0 1
)
╖╖1 2
{
╕╕ 
throw
╣╣ 
new
╣╣  
FileStoreException
╣╣ 0
(
╣╣0 1
$"
╣╣1 3
$str
╣╣3 E
{
╣╣E F
oldPath
╣╣F M
}
╣╣M N
$str
╣╣N j
"
╣╣j k
)
╣╣k l
;
╣╣l m
}
║║ 
var
╝╝ 
physicalNewPath
╝╝ #
=
╝╝$ %
GetPhysicalPath
╝╝& 5
(
╝╝5 6
newPath
╝╝6 =
)
╝╝= >
;
╝╝> ?
if
╛╛ 
(
╛╛ 
File
╛╛ 
.
╛╛ 
Exists
╛╛ 
(
╛╛  
physicalNewPath
╛╛  /
)
╛╛/ 0
||
╛╛1 3
	Directory
╛╛4 =
.
╛╛= >
Exists
╛╛> D
(
╛╛D E
physicalNewPath
╛╛E T
)
╛╛T U
)
╛╛U V
{
┐┐ 
throw
└└ 
new
└└  
FileStoreException
└└ 0
(
└└0 1
$"
└└1 3
$str
└└3 Z
{
└└Z [
newPath
└└[ b
}
└└b c
$str
└└c t
"
└└t u
)
└└u v
;
└└v w
}
┴┴ 
File
├├ 
.
├├ 
Move
├├ 
(
├├ 
physicalOldPath
├├ )
,
├├) *
physicalNewPath
├├+ :
)
├├: ;
;
├├; <
return
┼┼ 
Task
┼┼ 
.
┼┼ 
CompletedTask
┼┼ )
;
┼┼) *
}
╞╞ 
catch
╟╟ 
(
╟╟  
FileStoreException
╟╟ %
)
╟╟% &
{
╚╚ 
throw
╔╔ 
;
╔╔ 
}
╩╩ 
catch
╦╦ 
(
╦╦ 
	Exception
╦╦ 
ex
╦╦ 
)
╦╦  
{
╠╠ 
throw
══ 
new
══  
FileStoreException
══ ,
(
══, -
$"
══- /
$str
══/ A
{
══A B
oldPath
══B I
}
══I J
$str
══J P
{
══P Q
newPath
══Q X
}
══X Y
$str
══Y [
"
══[ \
,
══\ ]
ex
══^ `
)
══` a
;
══a b
}
╬╬ 
}
╧╧ 	
public
╤╤ 
Task
╤╤ 
CopyFileAsync
╤╤ !
(
╤╤! "
string
╤╤" (
srcPath
╤╤) 0
,
╤╤0 1
string
╤╤2 8
dstPath
╤╤9 @
)
╤╤@ A
{
╥╥ 	
try
╙╙ 
{
╘╘ 
var
╒╒ 
physicalSrcPath
╒╒ #
=
╒╒$ %
GetPhysicalPath
╒╒& 5
(
╒╒5 6
srcPath
╒╒6 =
)
╒╒= >
;
╒╒> ?
if
╫╫ 
(
╫╫ 
!
╫╫ 
File
╫╫ 
.
╫╫ 
Exists
╫╫  
(
╫╫  !
physicalSrcPath
╫╫! 0
)
╫╫0 1
)
╫╫1 2
{
╪╪ 
throw
┘┘ 
new
┘┘  
FileStoreException
┘┘ 0
(
┘┘0 1
$"
┘┘1 3
$str
┘┘3 =
{
┘┘= >
srcPath
┘┘> E
}
┘┘E F
$str
┘┘F W
"
┘┘W X
)
┘┘X Y
;
┘┘Y Z
}
┌┌ 
var
▄▄ 
physicalDstPath
▄▄ #
=
▄▄$ %
GetPhysicalPath
▄▄& 5
(
▄▄5 6
dstPath
▄▄6 =
)
▄▄= >
;
▄▄> ?
if
▐▐ 
(
▐▐ 
File
▐▐ 
.
▐▐ 
Exists
▐▐ 
(
▐▐  
physicalDstPath
▐▐  /
)
▐▐/ 0
||
▐▐1 3
	Directory
▐▐4 =
.
▐▐= >
Exists
▐▐> D
(
▐▐D E
physicalDstPath
▐▐E T
)
▐▐T U
)
▐▐U V
{
▀▀ 
throw
рр 
new
рр  
FileStoreException
рр 0
(
рр0 1
$"
рр1 3
$str
рр3 b
{
ррb c
dstPath
ррc j
}
ррj k
$str
ррk |
"
рр| }
)
рр} ~
;
рр~ 
}
сс 
File
уу 
.
уу 
Copy
уу 
(
уу 
GetPhysicalPath
уу )
(
уу) *
srcPath
уу* 1
)
уу1 2
,
уу2 3
GetPhysicalPath
уу4 C
(
ууC D
dstPath
ууD K
)
ууK L
)
ууL M
;
ууM N
return
хх 
Task
хх 
.
хх 
CompletedTask
хх )
;
хх) *
}
цц 
catch
чч 
(
чч  
FileStoreException
чч %
)
чч% &
{
шш 
throw
щщ 
;
щщ 
}
ъъ 
catch
ыы 
(
ыы 
	Exception
ыы 
ex
ыы 
)
ыы  
{
ьь 
throw
ээ 
new
ээ  
FileStoreException
ээ ,
(
ээ, -
$"
ээ- /
$str
ээ/ A
{
ээA B
srcPath
ээB I
}
ээI J
$str
ээJ P
{
ээP Q
dstPath
ээQ X
}
ээX Y
$str
ээY [
"
ээ[ \
,
ээ\ ]
ex
ээ^ `
)
ээ` a
;
ээa b
}
юю 
}
яя 	
public
ёё 
Task
ёё 
<
ёё 
Stream
ёё 
>
ёё  
GetFileStreamAsync
ёё .
(
ёё. /
string
ёё/ 5
path
ёё6 :
)
ёё: ;
{
ЄЄ 	
try
єє 
{
ЇЇ 
var
її 
physicalPath
її  
=
її! "
GetPhysicalPath
її# 2
(
її2 3
path
її3 7
)
її7 8
;
її8 9
if
ўў 
(
ўў 
!
ўў 
File
ўў 
.
ўў 
Exists
ўў  
(
ўў  !
physicalPath
ўў! -
)
ўў- .
)
ўў. /
{
°° 
throw
∙∙ 
new
∙∙  
FileStoreException
∙∙ 0
(
∙∙0 1
$"
∙∙1 3
$str
∙∙3 \
{
∙∙\ ]
path
∙∙] a
}
∙∙a b
$str
∙∙b s
"
∙∙s t
)
∙∙t u
;
∙∙u v
}
·· 
var
№№ 
stream
№№ 
=
№№ 
File
№№ !
.
№№! "
OpenRead
№№" *
(
№№* +
physicalPath
№№+ 7
)
№№7 8
;
№№8 9
return
■■ 
Task
■■ 
.
■■ 

FromResult
■■ &
<
■■& '
Stream
■■' -
>
■■- .
(
■■. /
stream
■■/ 5
)
■■5 6
;
■■6 7
}
   
catch
АА 
(
АА  
FileStoreException
АА %
)
АА% &
{
ББ 
throw
ВВ 
;
ВВ 
}
ГГ 
catch
ДД 
(
ДД 
	Exception
ДД 
ex
ДД 
)
ДД  
{
ЕЕ 
throw
ЖЖ 
new
ЖЖ  
FileStoreException
ЖЖ ,
(
ЖЖ, -
$"
ЖЖ- /
$str
ЖЖ/ S
{
ЖЖS T
path
ЖЖT X
}
ЖЖX Y
$str
ЖЖY [
"
ЖЖ[ \
,
ЖЖ\ ]
ex
ЖЖ^ `
)
ЖЖ` a
;
ЖЖa b
}
ЗЗ 
}
ИИ 	
public
КК 
Task
КК 
<
КК 
Stream
КК 
>
КК  
GetFileStreamAsync
КК .
(
КК. /
IFileStoreEntry
КК/ >
fileStoreEntry
КК? M
)
ККM N
{
ЛЛ 	
try
ММ 
{
НН 
var
ОО 
physicalPath
ОО  
=
ОО! "
GetPhysicalPath
ОО# 2
(
ОО2 3
fileStoreEntry
ОО3 A
.
ООA B
Path
ООB F
)
ООF G
;
ООG H
if
ПП 
(
ПП 
!
ПП 
File
ПП 
.
ПП 
Exists
ПП  
(
ПП  !
physicalPath
ПП! -
)
ПП- .
)
ПП. /
{
РР 
throw
СС 
new
СС  
FileStoreException
СС 0
(
СС0 1
$"
СС1 3
$str
СС3 \
{
СС\ ]
fileStoreEntry
СС] k
.
ССk l
Path
ССl p
}
ССp q
$strССq В
"ССВ Г
)ССГ Д
;ССД Е
}
ТТ 
var
ФФ 
stream
ФФ 
=
ФФ 
File
ФФ !
.
ФФ! "
OpenRead
ФФ" *
(
ФФ* +
physicalPath
ФФ+ 7
)
ФФ7 8
;
ФФ8 9
return
ЦЦ 
Task
ЦЦ 
.
ЦЦ 

FromResult
ЦЦ &
<
ЦЦ& '
Stream
ЦЦ' -
>
ЦЦ- .
(
ЦЦ. /
stream
ЦЦ/ 5
)
ЦЦ5 6
;
ЦЦ6 7
}
ЧЧ 
catch
ШШ 
(
ШШ  
FileStoreException
ШШ %
)
ШШ% &
{
ЩЩ 
throw
ЪЪ 
;
ЪЪ 
}
ЫЫ 
catch
ЬЬ 
(
ЬЬ 
	Exception
ЬЬ 
ex
ЬЬ 
)
ЬЬ  
{
ЭЭ 
throw
ЮЮ 
new
ЮЮ  
FileStoreException
ЮЮ ,
(
ЮЮ, -
$"
ЮЮ- /
$str
ЮЮ/ S
{
ЮЮS T
fileStoreEntry
ЮЮT b
.
ЮЮb c
Path
ЮЮc g
}
ЮЮg h
$str
ЮЮh j
"
ЮЮj k
,
ЮЮk l
ex
ЮЮm o
)
ЮЮo p
;
ЮЮp q
}
ЯЯ 
}
аа 	
public
вв 
async
вв 
Task
вв 
<
вв 
string
вв  
>
вв  !'
CreateFileFromStreamAsync
вв" ;
(
вв; <
string
вв< B
path
ввC G
,
ввG H
Stream
ввI O
inputStream
ввP [
,
вв[ \
bool
вв] a
	overwrite
ввb k
=
ввl m
false
ввn s
)
ввs t
{
гг 	
try
дд 
{
ее 
var
жж 
physicalPath
жж  
=
жж! "
GetPhysicalPath
жж# 2
(
жж2 3
path
жж3 7
)
жж7 8
;
жж8 9
if
ии 
(
ии 
!
ии 
	overwrite
ии 
&&
ии !
File
ии" &
.
ии& '
Exists
ии' -
(
ии- .
physicalPath
ии. :
)
ии: ;
)
ии; <
{
йй 
throw
кк 
new
кк  
FileStoreException
кк 0
(
кк0 1
$"
кк1 3
$str
кк3 G
{
ккG H
path
ккH L
}
ккL M
$str
ккM i
"
ккi j
)
ккj k
;
ккk l
}
лл 
if
нн 
(
нн 
	Directory
нн 
.
нн 
Exists
нн $
(
нн$ %
physicalPath
нн% 1
)
нн1 2
)
нн2 3
{
оо 
throw
пп 
new
пп  
FileStoreException
пп 0
(
пп0 1
$"
пп1 3
$str
пп3 G
{
ппG H
path
ппH L
}
ппL M
$str
ппM x
"
ппx y
)
ппy z
;
ппz {
}
░░ 
var
││ #
physicalDirectoryPath
││ )
=
││* +
Path
││, 0
.
││0 1
GetDirectoryName
││1 A
(
││A B
physicalPath
││B N
)
││N O
;
││O P
	Directory
┤┤ 
.
┤┤ 
CreateDirectory
┤┤ )
(
┤┤) *#
physicalDirectoryPath
┤┤* ?
)
┤┤? @
;
┤┤@ A
var
╢╢ 
fileInfo
╢╢ 
=
╢╢ 
new
╢╢ "
FileInfo
╢╢# +
(
╢╢+ ,
physicalPath
╢╢, 8
)
╢╢8 9
;
╢╢9 :
using
╖╖ 
(
╖╖ 
var
╖╖ 
outputStream
╖╖ '
=
╖╖( )
fileInfo
╖╖* 2
.
╖╖2 3
Create
╖╖3 9
(
╖╖9 :
)
╖╖: ;
)
╖╖; <
{
╕╕ 
await
╣╣ 
inputStream
╣╣ %
.
╣╣% &
CopyToAsync
╣╣& 1
(
╣╣1 2
outputStream
╣╣2 >
)
╣╣> ?
;
╣╣? @
}
║║ 
return
╝╝ 
path
╝╝ 
;
╝╝ 
}
╜╜ 
catch
╛╛ 
(
╛╛  
FileStoreException
╛╛ %
)
╛╛% &
{
┐┐ 
throw
└└ 
;
└└ 
}
┴┴ 
catch
┬┬ 
(
┬┬ 
	Exception
┬┬ 
ex
┬┬ 
)
┬┬  
{
├├ 
throw
── 
new
──  
FileStoreException
── ,
(
──, -
$"
──- /
$str
──/ C
{
──C D
path
──D H
}
──H I
$str
──I K
"
──K L
,
──L M
ex
──N P
)
──P Q
;
──Q R
}
┼┼ 
}
╞╞ 	
private
╬╬ 
string
╬╬ 
GetPhysicalPath
╬╬ &
(
╬╬& '
string
╬╬' -
path
╬╬. 2
)
╬╬2 3
{
╧╧ 	
try
╨╨ 
{
╤╤ 
path
╥╥ 
=
╥╥ 
this
╥╥ 
.
╥╥ 
NormalizePath
╥╥ )
(
╥╥) *
path
╥╥* .
)
╥╥. /
;
╥╥/ 0
var
╘╘ 
physicalPath
╘╘  
=
╘╘! "
String
╘╘# )
.
╘╘) *
IsNullOrEmpty
╘╘* 7
(
╘╘7 8
path
╘╘8 <
)
╘╘< =
?
╘╘> ?
_fileSystemPath
╘╘@ O
:
╘╘P Q
Path
╘╘R V
.
╘╘V W
Combine
╘╘W ^
(
╘╘^ _
_fileSystemPath
╘╘_ n
,
╘╘n o
path
╘╘p t
)
╘╘t u
;
╘╘u v
var
╫╫ 
pathIsAllowed
╫╫ !
=
╫╫" #
Path
╫╫$ (
.
╫╫( )
GetFullPath
╫╫) 4
(
╫╫4 5
physicalPath
╫╫5 A
)
╫╫A B
.
╫╫B C

StartsWith
╫╫C M
(
╫╫M N
_fileSystemPath
╫╫N ]
,
╫╫] ^
StringComparison
╫╫_ o
.
╫╫o p 
OrdinalIgnoreCase╫╫p Б
)╫╫Б В
;╫╫В Г
if
╪╪ 
(
╪╪ 
!
╪╪ 
pathIsAllowed
╪╪ "
)
╪╪" #
{
┘┘ 
throw
┌┌ 
new
┌┌  
FileStoreException
┌┌ 0
(
┌┌0 1
$"
┌┌1 3
$str
┌┌3 =
{
┌┌= >
path
┌┌> B
}
┌┌B C
$str┌┌C Д
"┌┌Д Е
)┌┌Е Ж
;┌┌Ж З
}
██ 
return
▌▌ 
physicalPath
▌▌ #
;
▌▌# $
}
▐▐ 
catch
▀▀ 
(
▀▀  
FileStoreException
▀▀ %
)
▀▀% &
{
рр 
throw
сс 
;
сс 
}
тт 
catch
уу 
(
уу 
	Exception
уу 
ex
уу 
)
уу  
{
фф 
throw
хх 
new
хх  
FileStoreException
хх ,
(
хх, -
$"
хх- /
$str
хх/ [
{
хх[ \
path
хх\ `
}
хх` a
$str
ххa c
"
ххc d
,
ххd e
ex
ххf h
)
ххh i
;
ххi j
}
цц 
}
чч 	
}
шш 
}щщ ·
ЖC:\Users\jay.ahir\Desktop\OrchardCore-main\OrchardCore-main\src\OrchardCore\OrchardCore.FileStorage.FileSystem\FileSystemStoreEntry.cs
	namespace 	
OrchardCore
 
. 
FileStorage !
.! "

FileSystem" ,
{ 
public 

class  
FileSystemStoreEntry %
:& '
IFileStoreEntry( 7
{ 
private 
readonly 
	IFileInfo "
	_fileInfo# ,
;, -
private		 
readonly		 
string		 
_path		  %
;		% &
internal  
FileSystemStoreEntry %
(% &
string& ,
path- 1
,1 2
	IFileInfo3 <
fileInfo= E
)E F
{ 	
	_fileInfo 
= 
fileInfo  
??! #
throw$ )
new* -!
ArgumentNullException. C
(C D
nameofD J
(J K
fileInfoK S
)S T
)T U
;U V
_path 
= 
path 
?? 
throw !
new" %!
ArgumentNullException& ;
(; <
nameof< B
(B C
pathC G
)G H
)H I
;I J
} 	
public 
string 
Path 
=> 
_path #
;# $
public 
string 
Name 
=> 
	_fileInfo '
.' (
Name( ,
;, -
public 
string 
DirectoryPath #
=>$ &
_path' ,
., -
	Substring- 6
(6 7
$num7 8
,8 9
_path: ?
.? @
Length@ F
-G H
NameI M
.M N
LengthN T
)T U
.U V
TrimEndV ]
(] ^
$char^ a
)a b
;b c
public 
DateTime 
LastModifiedUtc '
=>( *
	_fileInfo+ 4
.4 5
LastModified5 A
.A B
UtcDateTimeB M
;M N
public 
long 
Length 
=> 
	_fileInfo '
.' (
Length( .
;. /
public 
bool 
IsDirectory 
=>  "
	_fileInfo# ,
., -
IsDirectory- 8
;8 9
} 
} 